<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springboot集成aop日志]]></title>
    <url>%2F2019%2F02%2F13%2Fspringboot%E9%9B%86%E6%88%90aop%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[日常开发中假如是前后端完全分离，我们会习惯用浏览器去调用controller的接口来测试。这一个过程普通的日志功能会记录sql参数等一些基本信息。但是假如项目越来越庞大，我们的包越来越多，在维护项目和二次开发中去调用页面的相关接口后去寻找相关接口的包或者类就会有一定困难，我们可以通过aop去记录一次请求过程中的类名，方法名，请求url等。 这次的集成是在上一篇博客 spingboot项目打包 的基础上进行集成，我对config配置包向上移动了一层 代码引入相关依赖这里直接引入和aop相关的pom 1234567891011121314151617&lt;!-- aop依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt; &lt;version&gt;1.5.15&lt;/version&gt;&lt;/dependency&gt; 切面类先看一下包结构 在之前的项目基础上创建aop包 然后建立切面类LogAspect 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.ccsert.aop;import com.fasterxml.jackson.annotation.JsonInclude;import com.fasterxml.jackson.databind.ObjectMapper;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */@Aspect@Componentpublic class LogAspect &#123; private final static Logger logger = LoggerFactory.getLogger(LogAspect.class); //这里考虑到项目层次关系根据自己的项目去写表达式，此处是监测demo下所有的包下的controller包下以及其子包的类 @Pointcut("execution(public * com.ccsert.demo.*.controller..*.*(..))") public void controllerMethod() &#123; &#125; @Before("controllerMethod()") public void LogRequestInfo(JoinPoint joinPoint) throws Exception &#123; ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); StringBuffer requestLog = new StringBuffer(); requestLog.append("请求信息：") .append("URL = &#123;" + request.getRequestURI() + "&#125;,\t") .append("HTTP_METHOD = &#123;" + request.getMethod() + "&#125;,\t") .append("IP = &#123;" + request.getRemoteAddr() + "&#125;,\t") .append("CLASS_METHOD = &#123;" + joinPoint.getSignature().getDeclaringTypeName() + "." + joinPoint.getSignature().getName() + "&#125;,\t"); if (joinPoint.getArgs().length == 0) &#123; requestLog.append("ARGS = &#123;&#125; "); &#125; else &#123; requestLog.append("ARGS = " + new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL) .writeValueAsString(joinPoint.getArgs()[0]) + ""); &#125; logger.info(requestLog.toString()); &#125;&#125; 其实这样基本就完事了 Controler类123456789101112131415161718192021222324252627package com.ccsert.demo.login.controller;import com.ccsert.demo.login.model.UserInfo;import com.ccsert.demo.login.service.UserInfoService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */@RestController@RequestMapping("/user")public class UserInfoController &#123; @Autowired private UserInfoService userInfoService; @RequestMapping("getall") public List&lt;UserInfo&gt; selectAll()&#123; List&lt;UserInfo&gt; userInfos = userInfoService.selectAll(); return userInfos; &#125;&#125; 我们用上次写的controller进行测试 测试在浏览器访问接口 12342019-02-13 17:40:14.943 INFO 23672 --- [nio-8080-exec-5] com.ccsert.aop.LogAspect : 请求信息：URL = &#123;/user/getall&#125;, HTTP_METHOD = &#123;GET&#125;, IP = &#123;0:0:0:0:0:0:0:1&#125;, CLASS_METHOD = &#123;com.ccsert.demo.login.controller.UserInfoController.selectAll&#125;, ARGS = &#123;&#125; 2019-02-13 17:40:14.944 DEBUG 23672 --- [nio-8080-exec-5] c.c.d.l.dao.UserInfoMapper.selectAll : ==&gt; Preparing: SELECT id,user_name,password FROM user_info 2019-02-13 17:40:14.944 DEBUG 23672 --- [nio-8080-exec-5] c.c.d.l.dao.UserInfoMapper.selectAll : ==&gt; Parameters: 2019-02-13 17:40:14.948 DEBUG 23672 --- [nio-8080-exec-5] c.c.d.l.dao.UserInfoMapper.selectAll : &lt;== Total: 4 我们看见控制台成功记录了这次请求的请求url，请求方式，ip，以及完整的方法名 这样我们就整合是aop的日志功能更 想学习交流的可以加我的群 562942503]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spingboot项目打包]]></title>
    <url>%2F2019%2F02%2F12%2Fspingboot%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[上次我们集成了mybatis和druid数据源以及通用mapper。 集成这些以后我们已经可以拿这样的基础工程进行开发了。 不过在此之前我们先学习一下springboot项目打包，springboot因为内嵌了tomcat，所以可直接打成jar包运行，直接使用 java -jar jar包名字 即可直接运行。这里记录一下项目打包 项目打包我们通过使用maven-jar-plugin和maven-dependency-plugin插件打包 这样的打包以后就会是一个可以执行的jar，直接用java -jar jar包名字就可以运行项目 我们在pom.xml安装插件 1234567891011121314151617181920212223&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 安装完成以后我们就可以直接打包了 我们进入项目所在的目录 然后使用git命令窗口，也可以用dos命令，我们用cmd吧 我们用dos命令进入项目目录 然后先执行mvn clean 该命令是删除掉项目下target文件夹，springboot项目在运行的时候会把字节码静态资源等文件输出到target文件夹下 我们先将项目清理，然后在执行mvn package assembly:single 执行这个命令的时候会将项目运行测试后打包 看见BUILD SUCCESS就代表成功了。 我们看一下打好的包，项目打包后会存放在项目根目录下的target文件夹下 我们通过java -jar demo-0.0.1-SNAPSHOT.jar即可直接运行项目 我们用浏览器访问一下 好的这样就完事了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot集成ssm+druid+通用mapper]]></title>
    <url>%2F2019%2F02%2F02%2FSpringBoot%E9%9B%86%E6%88%90ssm-druid-%E9%80%9A%E7%94%A8mapper%2F</url>
    <content type="text"><![CDATA[简单介绍springboot首先什么是springboot？ springboot是spring的另外一款框架，设计目的是用来简化新的spring应用的搭建和开发时所需要的特定的配置，从而使开发过程不需要一次次无聊的复制那些一模一样的配置。 springboot内嵌tomcat，不需要部署war文件了，常常我们只需要将springboot项目打成jar包，然后通过: java -jar 项目名称即可，例如我有一个名叫demo的项目现在打包成了demo.jar需要在服务器上运行，那么我只需要这样: java -jar demo.jar springboot简化了maven的配置 而且springboot可以自动化配置，其实就将一些配置设置了有默认的配置。 ssm框架ssm框架即Spring+SpringMVC+Mybatis 这里引用一下百度的介绍 Spring Spring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。也可以称之为项目中的粘合剂。 Spring的核心思想是IoC（控制反转），即不再需要程序员去显式地new一个对象，而是让Spring框架帮你来完成这一切。 SpringMVC SpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。SpringMVC相当于SSH框架中struts。 mybatis mybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。 页面发送请求给控制器，控制器调用业务层处理逻辑，逻辑层向持久层发送请求，持久层与数据库交互，后将结果返回给业务层，业务层将处理逻辑发送给控制器，控制器再调用视图展现数据。 DruidDruid是阿里巴巴开源平台的一款项目，就是一款Java语言的数据库连接池，而且性能优越拥有强大的监控和扩展功能。 通用Mapper我们用Mybatis进行开发的时候肯定会遇到这样一种情况，有时候我的某个表只需要进行简单的增删改查，但是却需要些大量的xml，而且假如数据库结构发生改变的时候所有的实体类和sql都需要修改。（虽然一般不会改，改了可能会这样(￣ε(#￣)☆╰╮o(￣皿￣///)）这样大大的影响了我们的工作效率啊。为此就出现了通用mapper。 通用mapper是个什么鬼东西呢，怎么就这么棒呢，通用mapper就是为了解决单表增删该改查（没错你没看错只能解决单表，多表自己想办法(￣_,￣ )），基于mybatis插件，这时候开发人员不需要写sql，不需要在Dao中写方法，只要写好实体类就能支持相应的增删改查方法。是不是感觉很奈斯。 快速搭建一个springboot项目快速搭建，哼哼哼，你猜有多快，你跟本想不到有多快︿(￣︶￣)︿ 使用spring脚手架关于spring脚手架的使用，我们有两种方式 第一种是通过https://start.spring.io/ 这个地址直接搭建 打开后大概是这个样子 我们选择Maven Project因为我们的项目是用maven构建 ，语言选Java，Springboot版本默认就好。 然后在Group填写自己的项目组织所属，一般就是com,xxxx之类的啦(ーー゛)，Artifact 我们填自己的项目名，比如demo。最后Search for dependencies 我们可以指定web，填一个web回车就好了。 完事后大概就是这个样子 然后我们点击Generate Project将项目下载下来。 我们得到一个demo.zip的文件，然后将它解压 然后我们看下文件结构 │ .gitignore│ mvnw│ mvnw.cmd│ pom.xml│├─.mvn│ └─wrapper│ maven-wrapper.jar│ maven-wrapper.properties│└─src ├─main │ ├─java │ │ └─com │ │ └─ccsert │ │ └─demo │ │ DemoApplication.java │ │ │ └─resources │ │ application.properties │ │ │ ├─static │ └─templates └─test └─java └─com └─ccsert └─demo DemoApplicationTests.java 这里只需要知道pom.xml是用来管理maven依赖的，以及DemoApplication是启动类就可以了 接下来我们将项目导入到idea中。 点击Import Project 选择那个解压好的项目点击ok 然后这里选择maven点击下一步 然后一直下一步，最后finis就好了 这样我们就完成了springboot的创建 还有一种创建方式是通过idea自带的脚手架 工具创建，这里不在进行说明了。 SpringBoot快速入门既然项目搭建好了，那么我们可以开始写代码了。我们可以像写springMVC一样去使用springboot写web项目。 我们先创建一个controller的包，然后创建一个controller类，就叫HelloController吧,创建好以后是这个样子的 接下来国际惯例，hello world (&#42;/ω＼&#42;) 123456789101112131415161718package com.ccsert.demo.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */@RestController //RestController==@ResponseBody+@Controllerpublic class HelloController &#123; @RequestMapping("/hello") public String hello()&#123; return "hello SpringBoot"; &#125;&#125; 然后我们将项目运行起来，在DemoApplication直接点击绿色小箭头运行，就跟运行main方法一样，好吧就是运行main方法 我们从控制台看到tomcat的端口是8080，所以我们在浏览器输入http://localhost:8080/hello 就能直接访问你的项目了 这样一来我们很轻松的就完成了一个基础的springboot web项目。是不是很简单？ SpringBoot集成在上面我们已经完成了一个基础的项目，现在我们需要集成整合SSM以及druid连接池还有通用Mapper，在后面我会很详细的给大家讲解集成过程。 SpringBoot集成Druidspringboot简化了maven 的配置我们只要引入druid的maven库即可，不需要关心maven之间的依赖，springboot会自行帮我们处理好 我们直接引入druid的地址 将其引入pom.xml 12345678910111213&lt;!-- Druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt; 我们使用yaml的配置，所以将原本是application.properority的文件改名为application.yml 然后进行配置，记得先建立一个demo的数据库 123456789101112131415161718192021222324252627spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/demo?useUnicode=true&amp;characterEncoding=UTF8&amp;serverTimezone=UTC platform: mysql username: root password: 123456 initialSize: 3 minIdle: 3 maxActive: 30 maxWait: 15000 timeBetweenEvictionRunsMillis: 120000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 filters: stat,wall,log4j connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 druidRegistrationUrl: /druid/* resetEnable: true loginUsername: admin loginPassword: admin 我原本准备在yml里面写些注释的，但是后来启动会报错，就去掉了注释，关于德鲁伊配置的参数大家可以去看看相关的文档。 这里注意一下我使用的druid版本不是最新版本，最新版本的配置与旧版本的filters: stat,wall,log4j 不太一样，这个版本是当前使用人数最多的版本。 yml配置好以后我们还要对druid进行相关的配置 先在demo包下建一个config包，然后在config创建DruidConfig类,在此之前因为我们会需要写getset方法我们引入一下Lombok 1234567&lt;!-- lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 下面的是配置类的Java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.ccsert.demo.config;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import lombok.Getter;import lombok.Setter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Primary;import org.springframework.stereotype.Component;import java.sql.SQLException;@Component@ConfigurationProperties(prefix = "spring.datasource")@Getter@Setterpublic class DruidConfig &#123; private final Logger logger = LoggerFactory.getLogger(DruidConfig.class); private String driverClassName; private String url; private String username; private String password; private int initialSize; private int minIdle; private int maxActive; private long maxWait; private long timeBetweenEvictionRunsMillis; private long minEvictableIdleTimeMillis; private String validationQuery; private boolean testWhileIdle; private boolean testOnBorrow; private boolean testOnReturn; private boolean poolPreparedStatements; private int maxPoolPreparedStatementPerConnectionSize; private long removeAbandonedTimeoutMillis; private boolean removeAbandoned; private boolean logAbandoned; private boolean logDifferentThread; private String filters; private String connectionProperties; private boolean useGlobalDataSourceStat; //Druid 监控 Servlet 配置参数 private String druidRegistrationUrl; private boolean resetEnable; private String loginUsername; private String loginPassword; // Filters 配置参数 private String filtersUrlPatterns; private String exclusions; private int sessionStatMaxCount; private boolean sessionStatEnable; private String principalSessionName; private boolean profileEnable; @Bean(initMethod = "init", destroyMethod = "close") @Primary public DruidDataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driverClassName); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setInitialSize(initialSize); dataSource.setMinIdle(minIdle); dataSource.setMaxActive(maxActive); dataSource.setMaxWait(maxWait); dataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis); dataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis); dataSource.setValidationQuery(validationQuery); dataSource.setTestWhileIdle(testWhileIdle); dataSource.setTestOnBorrow(testOnBorrow); dataSource.setTestOnReturn(testOnReturn); dataSource.setPoolPreparedStatements(poolPreparedStatements); dataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize); dataSource.setRemoveAbandonedTimeoutMillis(removeAbandonedTimeoutMillis); dataSource.setRemoveAbandoned(removeAbandoned); dataSource.setLogDifferentThread(logDifferentThread); try &#123; dataSource.setFilters(filters); &#125; catch(SQLException e) &#123; e.printStackTrace(); logger.error("Druid URL过滤设置失败", e); &#125; dataSource.setConnectionProperties(connectionProperties); dataSource.setUseGlobalDataSourceStat(useGlobalDataSourceStat); return dataSource; &#125; @Bean public ServletRegistrationBean druidServlet() &#123; ServletRegistrationBean servletBean = new ServletRegistrationBean(new StatViewServlet(), druidRegistrationUrl); servletBean.addInitParameter("resetEnable", String.valueOf(resetEnable)); servletBean.addInitParameter("loginUsername", loginUsername); servletBean.addInitParameter("loginPassword", loginPassword); return servletBean; &#125;&#125; 紧接着我们让druid支持事务，在config包下创建一个TransactionConfig类 在此之前因为需要用到mybatis的注解，我们先将mybatis的依赖引入 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 然后下面是Java代码 12345678910111213141516171819202122232425262728293031package com.ccsert.demo.config;import com.alibaba.druid.pool.DruidDataSource;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.AutoConfigureAfter;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.transaction.annotation.TransactionManagementConfigurer;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */@Configuration@EnableTransactionManagement@AutoConfigureAfter(&#123;DruidConfig.class&#125;)@MapperScan(basePackages = &#123;"Mybatis 的 DAO 接口所在的包路径"&#125;)public class TransactionConfig implements TransactionManagementConfigurer &#123; @Autowired private DruidDataSource mDataSource; @Override public PlatformTransactionManager annotationDrivenTransactionManager() &#123; return new DataSourceTransactionManager(mDataSource); &#125;&#125; 最后我们配置一下druid的监控界面 在上面的DruidConfig类中加入一个方法 123456789@Beanpublic ServletRegistrationBean druidServlet() &#123; ServletRegistrationBean servletBean = new ServletRegistrationBean(new StatViewServlet(), druidRegistrationUrl); servletBean.addInitParameter("resetEnable", String.valueOf(resetEnable)); servletBean.addInitParameter("loginUsername", loginUsername); servletBean.addInitParameter("loginPassword", loginPassword); return servletBean;&#125; 这样就配置完毕了 然后我们开始集成mybatis，这个时候先不要着急访问druid的监控界面，也不要着急启动项目，因为我们还没有mapper 接口。 SpringBoot集成mybatis我们这里使用xml写sql所以在刚才的yml配置里加上一条配置用于扫描mapper.xml的映射文件。 123mybatis: mapper-locations: classpath:mappers/**/*Mapper.xml type-aliases-package: com.ccsert.demo.*.model 然后在resources下建一个文件夹名字为mappers 其实这样已经差不多可以使用了，这里我们先不着急使用 先集成一下通用mapper SpringBoot集成通用mapper先引入通用mapper 123456&lt;!-- 通用mapper --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 然后我们在config包下建立一个MyBatisConfig 类用于配置通用mapper 1234567891011121314151617181920212223242526272829303132333435package com.ccsert.demo.config;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import tk.mybatis.mapper.common.Mapper;import tk.mybatis.spring.mapper.MapperScannerConfigurer;import java.util.Properties;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */@Slf4j@Configurationpublic class MyBatisConfig &#123; @Bean public MapperScannerConfigurer mapperScannerConfigurer()&#123; log.info("加载MyBatisConfig....."); MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); mapperScannerConfigurer.setSqlSessionFactoryBeanName("sqlSessionFactory"); mapperScannerConfigurer.setBasePackage("com.ccsert.demo.login.dao"); Properties properties = new Properties(); properties.setProperty("mappers", Mapper.class.getName()); properties.setProperty("notEmpty", "false"); properties.setProperty("IDENTITY", "MYSQL"); properties.setProperty("ORDER","BEFORE"); mapperScannerConfigurer.setProperties(properties); return mapperScannerConfigurer; &#125;&#125; 好了结束了，就这么点点东西 我们直接开始使用测试一下 SpringBoot Smm使用在demo新建一个login包吧 然后在login包中建立dao，controller，service，model四个包，弄完以后大概就是这样 然后我们先建立一个简单的用户表，并新增些数据 1234567891011121314151617181920212223242526272829303132333435/*Navicat MySQL Data TransferSource Server : 本地Source Server Version : 50624Source Host : 127.0.0.1:3306Source Database : demoTarget Server Type : MYSQLTarget Server Version : 50624File Encoding : 65001Date: 2019-02-11 14:43:32*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for user_info-- ----------------------------DROP TABLE IF EXISTS `user_info`;CREATE TABLE `user_info` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_name` varchar(255) DEFAULT NULL, `password` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user_info-- ----------------------------INSERT INTO `user_info` VALUES ('1', 'ccsert', '123456');INSERT INTO `user_info` VALUES ('2', 'root', '654321');INSERT INTO `user_info` VALUES ('3', 'admin', '8848');INSERT INTO `user_info` VALUES ('4', '来个中文名', '111aaa'); 然后我们从实体类开始写 然后在model下建立一个实体类UserInfo，这里注意一下，我踩过几次坑了，这里必须使用驼峰命名法，因为我们的表名是带 _ 的所以因该从这里我们命名应当是UserInfo ，我们的通用mapper是根据实体类名去找表的。 1234567891011121314151617package com.ccsert.demo.login.model;import lombok.Getter;import lombok.Setter;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */@Getter@Setterpublic class UserInfo &#123; private Integer Id; private String UserName; private String Password;&#125; 接着是dao下建立一个UserInfoMapper接口，并继承通用mapper类 12345678910111213package com.ccsert.demo.login.dao;import com.ccsert.demo.login.model.UserInfo;import tk.mybatis.mapper.common.BaseMapper;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */public interface UserInfoMapper extends BaseMapper&lt;UserInfo&gt; &#123;&#125; 然后在service包下建立UserInfoService接口 在接口里写一个查询所有的方法 12345678package com.ccsert.demo.login.service;import com.ccsert.demo.login.model.UserInfo;import java.util.List;public interface UserInfoService &#123; List&lt;UserInfo&gt; selectAll();&#125; 接着在service包下建立一个impl的包 然后在包内建一个UserInfoService的实现类UserInfoServiceImpl 1234567891011121314151617181920212223242526package com.ccsert.demo.login.service.impl;import com.ccsert.demo.login.dao.UserInfoMapper;import com.ccsert.demo.login.model.UserInfo;import com.ccsert.demo.login.service.UserInfoService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */@Servicepublic class UserInfoServiceImpl implements UserInfoService &#123; @Autowired private UserInfoMapper userInfoMapper; @Override public List&lt;UserInfo&gt; selectAll() &#123; List&lt;UserInfo&gt; userInfos = userInfoMapper.selectAll(); return userInfos; &#125;&#125; 最后是controller包下建立一个UserInfoController 123456789101112131415161718192021222324252627package com.ccsert.demo.login.controller;import com.ccsert.demo.login.model.UserInfo;import com.ccsert.demo.login.service.UserInfoService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */@RestController@RequestMapping("/user")public class UserInfoController &#123; @Autowired private UserInfoService userInfoService; @RequestMapping("getall") public List&lt;UserInfo&gt; selectAll()&#123; List&lt;UserInfo&gt; userInfos = userInfoService.selectAll(); return userInfos; &#125;&#125; 最后我们还要在启动类上加一个mapper扫描的注解 1@MapperScan("com.ccsert.demo.login.dao") 导包时请注意，导入import tk.mybatis.spring.annotation.MapperScan;这个包 记得在事务配置上改为自己dao接口的路径 1@MapperScan(basePackages = &#123;"com.ccsert.demo.login.dao"&#125;) 我们运行一下，按照我写代码的方式，多半是要报错的。 1org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryConfiguration$EmbeddedTomcat': Initialization of bean failed; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration': Unsatisfied dependency expressed through method 'setConfigurers' parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'transactionConfig': Unsatisfied dependency expressed through field 'mDataSource'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSource' defined in class path resource [com/ccsert/demo/config/DruidConfig.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.alibaba.druid.pool.DruidDataSource]: Factory method 'dataSource' threw exception; nested exception is java.lang.NoClassDefFoundError: org/apache/log4j/Logger 果然是报错了(ノへ￣、) 不过这个错看起来很好解决，末尾说找不到log4j,讲道理导入log4j的依赖就完事了 12345&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt; 导入后重新启动项目是会又警告的，虽然开发运行没有影响但是在生产打包为jar可能会报错，这是因为springboot默认的日志是logback，而logback和log4j发生冲突了。 我们把logback排除掉即可。 然而真相并不是这样，其实是druid的锅，既然都已经给了更好的logback，我们就直接用就好哪里还要换一个又屏蔽一个的？(￣_,￣ ) 我们只要在yml的配置文件中去掉 filters: stat,wall,log4j 的log4j就完事了 上面的那个log4j我就放出来看看而已不用加进去。嘿嘿嘿~~ 我们最后在yml配置里加一个日志的配置 12345logging: file: logs/mass.log level: org.springframework: info com.ccsert: DEBUG 然后就能打印sql了。 然后再次运行，果断运行成功，其实前面的报错都是我装的，我早就考虑到这些问题了。（其实我压根不知道，还找了半天的错） 输入http://localhost:8080/user/getall访问 我们访问一下druid的监控 http://localhost:8080/druid/index.html 然后我们点击sql监控 我们可以看到我们之前所执行的sql都会被druid监控 总算搞完了，后面有时间会继续集成使用的组件。 这里感谢简书一位大佬的支持，其中有些代码摘抄于这位朋友的文章 附上原文链接https://www.jianshu.com/p/9dc6f4418a06]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机下Linux基本安装]]></title>
    <url>%2F2019%2F01%2F29%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8BLinux%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[第一步：工具准备所需要的工具有，vm虚拟机安装包，centos7发行版本，ok就这些，这里选择centos发行版本的原因是一般企业级的服务器都是他，7版本是最新版本，很多企业级也开始更换为最新版本。 这里我提供centos和vm虚拟机破解版的百度网盘链接 链接: https://pan.baidu.com/s/1oU26U89LP71OMX1PGfkHTg 提取码: 98vs 这里不提供vm虚拟机的安装教程，关于vm虚拟机安装请自行百度。后面可能有涉及到一些常用命令，可能会解释可能不会解释，未解释到位的请提出，或自行百度了解。 第二步：虚拟机创建首先创建虚拟机，看图就好 第三步：安装centos7系统]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vm虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带图片的博客]]></title>
    <url>%2F2019%2F01%2F29%2F%E5%B8%A6%E5%9B%BE%E7%89%87%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这里是带图片的博客 这里我会显示一张图片]]></content>
  </entry>
</search>
