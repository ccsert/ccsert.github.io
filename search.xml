<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[springBoot简单集成2(Mybatis+Druid多数据源配置)]]></title>
    <url>%2F2019%2F03%2F20%2FspringBoot%E7%AE%80%E5%8D%95%E9%9B%86%E6%88%902-Mybatis-Druid%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在日常开发中我们可能会用到多数据源开发，什么是多数据源？ 简单来讲的话，就是一个项目连接多个数据库。当然只是可能会用到，我暂时没见过应用场景，但是还是了解学习一下 此项目可以基于上一个简单集成项目进行简单的修改，就能实现多数据源了。 application.yml配置我们在上一个项目的基础上进行修改，实现多数据源配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950spring: datasource: type: com.alibaba.druid.pool.DruidDataSource url: jdbc:mysql://localhost:3306/demo?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver druid: one: username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/demo?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true initialSize: 5 minIdle: 5 maxActive: 20 initial-size: 3 min-idle: 3 max-active: 10 max-wait: 60000 two: username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/layui?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true initialSize: 5 minIdle: 5 maxActive: 20 initial-size: 6 min-idle: 6 max-active: 20 max-wait: 12000 stat-view-servlet: login-username: admin login-password: admin filter: stat: log-slow-sql: true slow-sql-millis: 2000mybatis: mapper-locations: classpath:mappers/**/**/*Mapper.xml type-aliases-package: com.ccsert.spdruid.*.model configuration: map-underscore-to-camel-case: truelogging: file: logs/mass.log level: org.springframework: info com.ccsert: DEBUG 着是完整的配置 主要在druid数据源和mybatis的mapper.xml进行了细微修改 这里我建立一个layui数据库，里面有个和demo里一样的表，数据和结构都一样，方便等会测试 包结构调整，代码修改包结构调整我们先把mapper接口修改一下 在原来的mapper包下建立两个包，一个one，一个two 然后把之前的mapper接口分别复制到one和two下 然后改一下名字 改完以后大概就是这个样子 代码修改把之前的mapper注解都去掉 后面会用别的方法去映射 这是oneMapper 1234567891011121314package com.ccsert.spdruid.test.mapper.one;import com.ccsert.spdruid.test.model.TestUser;import java.util.List;public interface TestUserOneMapper &#123; List&lt;TestUser&gt; getall(); TestUser getById(Integer id); int save(TestUser testUser);&#125; 这是twoMapper 12345678package com.ccsert.spdruid.test.mapper.two;import com.ccsert.spdruid.test.model.TestUser;public interface TestUserTwoMapper &#123; TestUser getById(Integer id);&#125; 这里为了方便我就只写一个接口 然后我们在修改一下service实现类 123456789101112131415161718192021222324252627282930313233package com.ccsert.spdruid.test.service.impl;import com.ccsert.spdruid.test.mapper.one.TestUserOneMapper;import com.ccsert.spdruid.test.mapper.two.TestUserTwoMapper;import com.ccsert.spdruid.test.model.TestUser;import com.ccsert.spdruid.test.service.TestUserService;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;@Servicepublic class TestUserServiceImpl implements TestUserService &#123; @Resource private TestUserOneMapper testUserOneMapper; @Resource private TestUserTwoMapper testUserTwoMapper; @Override public List&lt;TestUser&gt; getall() &#123; return testUserOneMapper.getall(); &#125; @Override public TestUser getById(Integer id) &#123; return testUserTwoMapper.getById(id); &#125; @Override public int save(TestUser testUser) &#123; return testUserOneMapper.save(testUser); &#125;&#125; getById方法让他去调用twoMapper 其余的还是让它去调用原来的接口 配置文件修改然后我们把xml的位置移动一下 在resources下的mappers下在建立两个文件夹 一个one 一个two 然后在把之前的TestUser目录复制两份到one和two下 把原来的TestUser删除掉 在把之前的xml名字修改一下 改完以后大概就是这个样子了 onemapper.xml的内容保持不变 主要写一下twomapper.xml的save保存方法 1234567891011121314151617&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.ccsert.spdruid.test.mapper.two.TestUserTwoMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.ccsert.spdruid.test.model.TestUser" &gt; &lt;id column="id" property="Id" /&gt; &lt;result column="user_name" property="userName"/&gt; &lt;result column="password" property="password" /&gt; &lt;/resultMap&gt; &lt;select id="getById" parameterType="Integer" resultMap="BaseResultMap"&gt; SELECT id,user_name,password FROM test_user WHERE id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 因为这里的mapper接口路径是修改过的，onemapper.xml要注意一下 多数据源配置准备工作做好了接着就是配置多数据源了 在test包下建立一个config包，用于存放配置 然后在config包下建立一个MultiDataSourceConfig类 123456789101112131415161718192021222324package com.ccsert.spdruid.test.config;import com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceBuilder;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import javax.sql.DataSource;@Configurationpublic class MultiDataSourceConfig &#123; @Primary @Bean(name = "oneDataSource") @ConfigurationProperties("spring.datasource.druid.one") public DataSource dataSourceOne()&#123; return DruidDataSourceBuilder.create().build(); &#125; @Bean(name = "twoDataSource") @ConfigurationProperties("spring.datasource.druid.two") public DataSource dataSourceTwo()&#123; return DruidDataSourceBuilder.create().build(); &#125;&#125; 这里的ConfigurationProperties是获取的yml或者properties里的值 spring.datasource.druid.one和spring.datasource.druid.two就是我们配置的数据源 Primary只能指定一个为默认数据源，这里指定了one数据库 在config下建立DataSource1Config类，用于配置数据源one 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.ccsert.spdruid.test.config;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.SqlSessionTemplate;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import javax.sql.DataSource;@Configuration@MapperScan(basePackages = "com.ccsert.spdruid.test.mapper.one", sqlSessionTemplateRef = "test1SqlSessionTemplate")public class DataSource1Config &#123; @Bean(name = "test1SqlSessionFactory") @Primary public SqlSessionFactory testSqlSessionFactory(@Qualifier("oneDataSource") DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mappers/one/**/*Mapper.xml")); return bean.getObject(); &#125; @Bean(name = "test1TransactionManager") @Primary public DataSourceTransactionManager testTransactionManager(@Qualifier("oneDataSource") DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; @Bean(name = "test1SqlSessionTemplate") @Primary public SqlSessionTemplate testSqlSessionTemplate(@Qualifier("test1SqlSessionFactory") SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546```@MapperScan(basePackages = &quot;com.ccsert.spdruid.test.mapper.one&quot;, sqlSessionTemplateRef = &quot;test1SqlSessionTemplate&quot;)```指定了实体类的路径，这里就完成了映射，所以不需要在mapper接口上写@Mapper注解然后在建立一个DataSource2Config类内容和上面的差不多```javapackage com.ccsert.spdruid.test.config;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.SqlSessionTemplate;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.core.io.support.PathMatchingResourcePatternResolver;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import javax.sql.DataSource;@Configuration@MapperScan(basePackages = &quot;com.ccsert.spdruid.test.mapper.two&quot;, sqlSessionTemplateRef = &quot;test2SqlSessionTemplate&quot;)public class DataSource2Config &#123; @Bean(name = &quot;test2SqlSessionFactory&quot;) public SqlSessionFactory testSqlSessionFactory(@Qualifier(&quot;twoDataSource&quot;) DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean bean = new SqlSessionFactoryBean(); bean.setDataSource(dataSource); bean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(&quot;classpath:mappers/two/**/*Mapper.xml&quot;)); return bean.getObject(); &#125; @Bean(name = &quot;test2TransactionManager&quot;) public DataSourceTransactionManager testTransactionManager(@Qualifier(&quot;twoDataSource&quot;) DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; @Bean(name = &quot;test2SqlSessionTemplate&quot;) public SqlSessionTemplate testSqlSessionTemplate(@Qualifier(&quot;test2SqlSessionFactory&quot;) SqlSessionFactory sqlSessionFactory) throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 注意这两个路径写成自己的不要搞错了 到这里就配置完成了 测试使用我们先访问一下接口能否调通 启动项目然后使用谷歌插件访问接口 可以看到我们两个接口都调用成功 我们去druid的监控界面查看一下执行的sql和数据源信息 可以看到druid监控了我们执行的两条sql，以及两个数据源信息]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot简单集成1(druid+mybatis)]]></title>
    <url>%2F2019%2F03%2F18%2Fspringboot%E7%AE%80%E5%8D%95%E9%9B%86%E6%88%901%2F</url>
    <content type="text"><![CDATA[在前面的文章中，我们对springboot开发中一些常用的框架进行了集成，但是发现还是存在一些问题，比如druid还需要比较长的固有配置，实际上druid官方是提供了相关的starters包的，内部采用默认配置。 什么是springboot的starters包？SpringBoot Starters是基于约定优于配置的理念来设计的，像之前的集成中还是有一定的配置量的，当然我们只是用Java代码在进行配置，SpringBoot Starters中有两个核心组件，一个是自动配置代码，一个是自动配置模块和其它有用的相关依赖。 这也就意味着，我们只要引入某个Starters就可以使相关框架拥有默认配置的能力，除非我们需要特定配置，一般情况下我们只需要少部分配置或者不配置就可以使用相关的组件了。 Druid是提供了相关的Starters，我们只需要引入Starters到pom.xml就可以直接使用了 通过Starters包集成Druid这次我们用idea内部的构建工具来创建一个SpringBoot项目 这个时候我们已经完成了一大半工作了，接着我们在pom.xml引入druid的Starters 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; 数据库我们使用MySQL的所以在引入一个MySQL的连接驱动 1234&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;&lt;/dependency&gt; 接着配置一下application.yml就基本完成了 12345678910111213141516171819spring: datasource: type: com.alibaba.druid.pool.DruidDataSource url: jdbc:mysql://localhost:3306/demo?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true username: root password: 123456 driver-class-name: com.mysql.cj.jdbc.Driver druid: initial-size: 3 min-idle: 3 max-active: 10 max-wait: 60000 stat-view-servlet: login-username: admin login-password: admin filter: stat: log-slow-sql: true slow-sql-millis: 2000 我们直接启动项目 访问http://localhost:8080/druid/login.html地址，就可以看见druid的监控界面了 然后输入配置文件中配置的用户名和密码进行登录admin 可以看到我们项目的基本信息以及数据源。 这样比上次的druid集成要简单很多对吧 我们在进一步集成mybatis 集成mybatis引入mybatis先引入xml节点 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; 为了方便测试先建个表 123456789101112131415161718192021222324252627282930313233343536373839/* Navicat Premium Data Transfer Source Server : localhost_3306 Source Server Type : MySQL Source Server Version : 50643 Source Host : localhost:3306 Source Schema : demo Target Server Type : MySQL Target Server Version : 50643 File Encoding : 65001 Date: 18/03/2019 14:20:08*/SET NAMES utf8mb4;SET FOREIGN_KEY_CHECKS = 0;-- ------------------------------ Table structure for test_user-- ----------------------------DROP TABLE IF EXISTS `test_user`;CREATE TABLE `test_user` ( `id` int(255) NOT NULL AUTO_INCREMENT COMMENT '主键', `user_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '用户名', `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '密码', PRIMARY KEY (`id`) USING BTREE) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;-- ------------------------------ Records of test_user-- ----------------------------INSERT INTO `test_user` VALUES (1, '用户', '123456');INSERT INTO `test_user` VALUES (2, '胡汉三', 'hhs123456');INSERT INTO `test_user` VALUES (3, '王五', '123456');INSERT INTO `test_user` VALUES (4, 'test', 'test');SET FOREIGN_KEY_CHECKS = 1; 这个表是建立在我配置文件指定的数据库下的，请注意一下 配置mybatis1234567891011mybatis: mapper-locations: classpath:mappers/**/*Mapper.xml type-aliases-package: com.ccsert.spdruid.*.model configuration: map-underscore-to-camel-case: truelogging: file: logs/mass.log level: org.springframework: info com.ccsert: DEBUG 配置一下mybatis和log日志以及sql打印 然后在resources下建立mappers用来存放mapper,xml文件，这些步骤其实和上次的集成是一样的基本没区别 接着建立一个test包 然后在test包建立mapper，service，model，controller四个包准备工作基本做完了 mybatis使用开始使用，先在model下建立TestUser类 emmm用一下lombok，引入一下 关于lombok，idea支持需要安装相应的插件 按Ctrl+Alt+S，唤出设置 点击Plugins搜索Lombok 然后安装Lombok Plugin插件，接着重启idea，这样idea就支持lombok注解了。（上次没有讲，真是抱歉） 接着刚才 123456789101112package com.ccsert.spdruid.test.model;import lombok.Getter;import lombok.Setter;import lombok.ToString;@Getter@Setter@ToStringpublic class TestUser &#123; private Integer Id; private String userName; private String password;&#125; 然后我们写mapper 在mapper建立一个TestUserMapper接口 12345678910111213141516package com.ccsert.spdruid.test.mapper;import com.ccsert.spdruid.test.model.TestUser;import org.apache.ibatis.annotations.Mapper;import java.util.List;@Mapperpublic interface TestUserMapper &#123; List&lt;TestUser&gt; getall(); TestUser getById(Integer id); int save(TestUser testUser);&#125; 然后我们写Service层 在service包下建立UserTestService接口 这里就写一个根据id查用户和查询所有以及新增用户三个方法 1234567891011package com.ccsert.spdruid.test.service;import com.ccsert.spdruid.test.model.TestUser;import java.util.List;public interface TestUserService &#123; List&lt;TestUser&gt; getall(); TestUser getById(Integer id); int save(TestUser testUser);&#125; 然后在service下建一个impl包，在impl包下创建一个TestUserService的实现类TestUserServiceImpl 123456789101112131415161718192021222324252627282930package com.ccsert.spdruid.test.service.impl;import com.ccsert.spdruid.test.mapper.TestUserMapper;import com.ccsert.spdruid.test.model.TestUser;import com.ccsert.spdruid.test.service.TestUserService;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.List;@Servicepublic class TestUserServiceImpl implements TestUserService &#123; @Resource private TestUserMapper testUserMapper; @Override public List&lt;TestUser&gt; getall() &#123; return testUserMapper.getall(); &#125; @Override public TestUser getById(Integer id) &#123; return testUserMapper.getById(id); &#125; @Override public int save(TestUser testUser) &#123; return testUserMapper.save(testUser); &#125;&#125; 接下来就是写xml了，在mappers目录下建立一个TestUser目录，然后在该目录下建立一个TestUserMapper.xml文件 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.ccsert.spdruid.test.mapper.TestUserMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.ccsert.spdruid.test.model.TestUser" &gt; &lt;id column="id" property="Id" /&gt; &lt;result column="user_name" property="userName"/&gt; &lt;result column="password" property="password" /&gt; &lt;/resultMap&gt; &lt;select id="getall" resultMap="BaseResultMap"&gt; SELECT id,user_name,password FROM test_user &lt;/select&gt; &lt;select id="getById" parameterType="Integer" resultMap="BaseResultMap"&gt; SELECT id,user_name,password FROM test_user WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;insert id="insert" parameterType="com.ccsert.spdruid.test.model.TestUser" &gt; INSERT INTO save (user_name,password) VALUES (#&#123;user_name&#125;, #&#123;password&#125;)&lt;/insert&gt;&lt;/mapper&gt; 建立TestUserController类 1234567891011121314151617181920212223242526272829303132package com.ccsert.spdruid.test.controller;import com.ccsert.spdruid.test.model.TestUser;import com.ccsert.spdruid.test.service.TestUserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;@RestControllerpublic class TestUserController &#123; @Autowired private TestUserService testUserService; @GetMapping("/getall") public List&lt;TestUser&gt; getAll()&#123; return testUserService.getall(); &#125; @GetMapping("/getById/&#123;id&#125;") public TestUser getById(@PathVariable Integer id)&#123; return testUserService.getById(id); &#125; @PostMapping("/save") public int save(TestUser testUser)&#123; return testUserService.save(testUser); &#125;&#125; 这里用到RESTful api的设计风格使请求地址看起来更美观 测试使用启动项目然后用Restlet Client - REST API Testing插件测试一下，Restlet Client - REST API Testing是一款chrome的扩展插件，功能类似于postman，建立大家可以装一个。需要翻墙，到时候我会把相关插件工具发在群里。 先测试getall，这里geitall必须使用get请求 然后接着是getById，这里传参的时候只需要把id放在请求路径后面就可以了，比如getById/1，同样也必须是get请求 接着是save，save必须是post请求，保存用户成功后会返回一个条数 因为id是自增长所以不需要传入，去数据库查看一下是否有该数据 可以看到该数据已经成功插入了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot集成aop日志]]></title>
    <url>%2F2019%2F02%2F13%2Fspringboot%E9%9B%86%E6%88%90aop%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[日常开发中假如是前后端完全分离，我们会习惯用浏览器去调用controller的接口来测试。这一个过程普通的日志功能会记录sql参数等一些基本信息。但是假如项目越来越庞大，我们的包越来越多，在维护项目和二次开发中去调用页面的相关接口后去寻找相关接口的包或者类就会有一定困难，我们可以通过aop去记录一次请求过程中的类名，方法名，请求url等。 这次的集成是在上一篇博客 spingboot项目打包 的基础上进行集成，我对config配置包向上移动了一层 代码引入相关依赖这里直接引入和aop相关的pom 1234567891011121314151617&lt;!-- aop依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.1.4.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.swagger&lt;/groupId&gt; &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt; &lt;version&gt;1.5.15&lt;/version&gt;&lt;/dependency&gt; 切面类先看一下包结构 在之前的项目基础上创建aop包 然后建立切面类LogAspect 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.ccsert.aop;import com.fasterxml.jackson.annotation.JsonInclude;import com.fasterxml.jackson.databind.ObjectMapper;import org.aspectj.lang.JoinPoint;import org.aspectj.lang.annotation.AfterReturning;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Before;import org.aspectj.lang.annotation.Pointcut;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import org.springframework.web.context.request.RequestContextHolder;import org.springframework.web.context.request.ServletRequestAttributes;import javax.servlet.http.HttpServletRequest;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */@Aspect@Componentpublic class LogAspect &#123; private final static Logger logger = LoggerFactory.getLogger(LogAspect.class); //这里考虑到项目层次关系根据自己的项目去写表达式，此处是监测demo下所有的包下的controller包下以及其子包的类 @Pointcut("execution(public * com.ccsert.demo.*.controller..*.*(..))") public void controllerMethod() &#123; &#125; @Before("controllerMethod()") public void LogRequestInfo(JoinPoint joinPoint) throws Exception &#123; ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes(); HttpServletRequest request = attributes.getRequest(); StringBuffer requestLog = new StringBuffer(); requestLog.append("请求信息：") .append("URL = &#123;" + request.getRequestURI() + "&#125;,\t") .append("HTTP_METHOD = &#123;" + request.getMethod() + "&#125;,\t") .append("IP = &#123;" + request.getRemoteAddr() + "&#125;,\t") .append("CLASS_METHOD = &#123;" + joinPoint.getSignature().getDeclaringTypeName() + "." + joinPoint.getSignature().getName() + "&#125;,\t"); if (joinPoint.getArgs().length == 0) &#123; requestLog.append("ARGS = &#123;&#125; "); &#125; else &#123; requestLog.append("ARGS = " + new ObjectMapper().setSerializationInclusion(JsonInclude.Include.NON_NULL) .writeValueAsString(joinPoint.getArgs()[0]) + ""); &#125; logger.info(requestLog.toString()); &#125;&#125; 其实这样基本就完事了 Controler类123456789101112131415161718192021222324252627package com.ccsert.demo.login.controller;import com.ccsert.demo.login.model.UserInfo;import com.ccsert.demo.login.service.UserInfoService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */@RestController@RequestMapping("/user")public class UserInfoController &#123; @Autowired private UserInfoService userInfoService; @RequestMapping("getall") public List&lt;UserInfo&gt; selectAll()&#123; List&lt;UserInfo&gt; userInfos = userInfoService.selectAll(); return userInfos; &#125;&#125; 我们用上次写的controller进行测试 测试在浏览器访问接口 12342019-02-13 17:40:14.943 INFO 23672 --- [nio-8080-exec-5] com.ccsert.aop.LogAspect : 请求信息：URL = &#123;/user/getall&#125;, HTTP_METHOD = &#123;GET&#125;, IP = &#123;0:0:0:0:0:0:0:1&#125;, CLASS_METHOD = &#123;com.ccsert.demo.login.controller.UserInfoController.selectAll&#125;, ARGS = &#123;&#125; 2019-02-13 17:40:14.944 DEBUG 23672 --- [nio-8080-exec-5] c.c.d.l.dao.UserInfoMapper.selectAll : ==&gt; Preparing: SELECT id,user_name,password FROM user_info 2019-02-13 17:40:14.944 DEBUG 23672 --- [nio-8080-exec-5] c.c.d.l.dao.UserInfoMapper.selectAll : ==&gt; Parameters: 2019-02-13 17:40:14.948 DEBUG 23672 --- [nio-8080-exec-5] c.c.d.l.dao.UserInfoMapper.selectAll : &lt;== Total: 4 我们看见控制台成功记录了这次请求的请求url，请求方式，ip，以及完整的方法名 这样我们就整合是aop的日志功能更 想学习交流的可以加我的群 562942503]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>aop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spingboot项目打包]]></title>
    <url>%2F2019%2F02%2F12%2Fspingboot%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[上次我们集成了mybatis和druid数据源以及通用mapper。 集成这些以后我们已经可以拿这样的基础工程进行开发了。 不过在此之前我们先学习一下springboot项目打包，springboot因为内嵌了tomcat，所以可直接打成jar包运行，直接使用 java -jar jar包名字 即可直接运行。这里记录一下项目打包 项目打包我们通过使用maven-jar-plugin和maven-dependency-plugin插件打包 这样的打包以后就会是一个可以执行的jar，直接用java -jar jar包名字就可以运行项目 我们在pom.xml安装插件 1234567891011121314151617181920212223&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.5&lt;/version&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;mainClass&gt;com.xxg.Main&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;descriptorRefs&gt; &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt; &lt;/descriptorRefs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 安装完成以后我们就可以直接打包了 我们进入项目所在的目录 然后使用git命令窗口，也可以用dos命令，我们用cmd吧 我们用dos命令进入项目目录 然后先执行mvn clean 该命令是删除掉项目下target文件夹，springboot项目在运行的时候会把字节码静态资源等文件输出到target文件夹下 我们先将项目清理，然后在执行mvn package assembly:single 执行这个命令的时候会将项目运行测试后打包 看见BUILD SUCCESS就代表成功了。 我们看一下打好的包，项目打包后会存放在项目根目录下的target文件夹下 我们通过java -jar demo-0.0.1-SNAPSHOT.jar即可直接运行项目 我们用浏览器访问一下 好的这样就完事了。]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot集成ssm+druid+通用mapper]]></title>
    <url>%2F2019%2F02%2F02%2FSpringBoot%E9%9B%86%E6%88%90ssm-druid-%E9%80%9A%E7%94%A8mapper%2F</url>
    <content type="text"><![CDATA[简单介绍springboot首先什么是springboot？ springboot是spring的另外一款框架，设计目的是用来简化新的spring应用的搭建和开发时所需要的特定的配置，从而使开发过程不需要一次次无聊的复制那些一模一样的配置。 springboot内嵌tomcat，不需要部署war文件了，常常我们只需要将springboot项目打成jar包，然后通过: java -jar 项目名称即可，例如我有一个名叫demo的项目现在打包成了demo.jar需要在服务器上运行，那么我只需要这样: java -jar demo.jar springboot简化了maven的配置 而且springboot可以自动化配置，其实就将一些配置设置了有默认的配置。 ssm框架ssm框架即Spring+SpringMVC+Mybatis 这里引用一下百度的介绍 Spring Spring就像是整个项目中装配bean的大工厂，在配置文件中可以指定使用特定的参数去调用实体类的构造方法来实例化对象。也可以称之为项目中的粘合剂。 Spring的核心思想是IoC（控制反转），即不再需要程序员去显式地new一个对象，而是让Spring框架帮你来完成这一切。 SpringMVC SpringMVC在项目中拦截用户请求，它的核心Servlet即DispatcherServlet承担中介或是前台这样的职责，将用户请求通过HandlerMapping去匹配Controller，Controller就是具体对应请求所执行的操作。SpringMVC相当于SSH框架中struts。 mybatis mybatis是对jdbc的封装，它让数据库底层操作变的透明。mybatis的操作都是围绕一个sqlSessionFactory实例展开的。mybatis通过配置文件关联到各实体类的Mapper文件，Mapper文件中配置了每个类对数据库所需进行的sql语句映射。在每次与数据库交互时，通过sqlSessionFactory拿到一个sqlSession，再执行sql命令。 页面发送请求给控制器，控制器调用业务层处理逻辑，逻辑层向持久层发送请求，持久层与数据库交互，后将结果返回给业务层，业务层将处理逻辑发送给控制器，控制器再调用视图展现数据。 DruidDruid是阿里巴巴开源平台的一款项目，就是一款Java语言的数据库连接池，而且性能优越拥有强大的监控和扩展功能。 通用Mapper我们用Mybatis进行开发的时候肯定会遇到这样一种情况，有时候我的某个表只需要进行简单的增删改查，但是却需要些大量的xml，而且假如数据库结构发生改变的时候所有的实体类和sql都需要修改。（虽然一般不会改，改了可能会这样(￣ε(#￣)☆╰╮o(￣皿￣///)）这样大大的影响了我们的工作效率啊。为此就出现了通用mapper。 通用mapper是个什么鬼东西呢，怎么就这么棒呢，通用mapper就是为了解决单表增删该改查（没错你没看错只能解决单表，多表自己想办法(￣_,￣ )），基于mybatis插件，这时候开发人员不需要写sql，不需要在Dao中写方法，只要写好实体类就能支持相应的增删改查方法。是不是感觉很奈斯。 快速搭建一个springboot项目快速搭建，哼哼哼，你猜有多快，你跟本想不到有多快︿(￣︶￣)︿ 使用spring脚手架关于spring脚手架的使用，我们有两种方式 第一种是通过https://start.spring.io/ 这个地址直接搭建 打开后大概是这个样子 我们选择Maven Project因为我们的项目是用maven构建 ，语言选Java，Springboot版本默认就好。 然后在Group填写自己的项目组织所属，一般就是com,xxxx之类的啦(ーー゛)，Artifact 我们填自己的项目名，比如demo。最后Search for dependencies 我们可以指定web，填一个web回车就好了。 完事后大概就是这个样子 然后我们点击Generate Project将项目下载下来。 我们得到一个demo.zip的文件，然后将它解压 然后我们看下文件结构 │ .gitignore│ mvnw│ mvnw.cmd│ pom.xml│├─.mvn│ └─wrapper│ maven-wrapper.jar│ maven-wrapper.properties│└─src ├─main │ ├─java │ │ └─com │ │ └─ccsert │ │ └─demo │ │ DemoApplication.java │ │ │ └─resources │ │ application.properties │ │ │ ├─static │ └─templates └─test └─java └─com └─ccsert └─demo DemoApplicationTests.java 这里只需要知道pom.xml是用来管理maven依赖的，以及DemoApplication是启动类就可以了 接下来我们将项目导入到idea中。 点击Import Project 选择那个解压好的项目点击ok 然后这里选择maven点击下一步 然后一直下一步，最后finis就好了 这样我们就完成了springboot的创建 还有一种创建方式是通过idea自带的脚手架 工具创建，这里不在进行说明了。 SpringBoot快速入门既然项目搭建好了，那么我们可以开始写代码了。我们可以像写springMVC一样去使用springboot写web项目。 我们先创建一个controller的包，然后创建一个controller类，就叫HelloController吧,创建好以后是这个样子的 接下来国际惯例，hello world (&#42;/ω＼&#42;) 123456789101112131415161718package com.ccsert.demo.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */@RestController //RestController==@ResponseBody+@Controllerpublic class HelloController &#123; @RequestMapping("/hello") public String hello()&#123; return "hello SpringBoot"; &#125;&#125; 然后我们将项目运行起来，在DemoApplication直接点击绿色小箭头运行，就跟运行main方法一样，好吧就是运行main方法 我们从控制台看到tomcat的端口是8080，所以我们在浏览器输入http://localhost:8080/hello 就能直接访问你的项目了 这样一来我们很轻松的就完成了一个基础的springboot web项目。是不是很简单？ SpringBoot集成在上面我们已经完成了一个基础的项目，现在我们需要集成整合SSM以及druid连接池还有通用Mapper，在后面我会很详细的给大家讲解集成过程。 SpringBoot集成Druidspringboot简化了maven 的配置我们只要引入druid的maven库即可，不需要关心maven之间的依赖，springboot会自行帮我们处理好 我们直接引入druid的地址 将其引入pom.xml 12345678910111213&lt;!-- Druid连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.5&lt;/version&gt;&lt;/dependency&gt;&lt;!-- mysql --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;6.0.6&lt;/version&gt;&lt;/dependency&gt; 我们使用yaml的配置，所以将原本是application.properority的文件改名为application.yml 然后进行配置，记得先建立一个demo的数据库 123456789101112131415161718192021222324252627spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/demo?useUnicode=true&amp;characterEncoding=UTF8&amp;serverTimezone=UTC platform: mysql username: root password: 123456 initialSize: 3 minIdle: 3 maxActive: 30 maxWait: 15000 timeBetweenEvictionRunsMillis: 120000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 filters: stat,wall,log4j connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000 druidRegistrationUrl: /druid/* resetEnable: true loginUsername: admin loginPassword: admin 我原本准备在yml里面写些注释的，但是后来启动会报错，就去掉了注释，关于德鲁伊配置的参数大家可以去看看相关的文档。 这里注意一下我使用的druid版本不是最新版本，最新版本的配置与旧版本的filters: stat,wall,log4j 不太一样，这个版本是当前使用人数最多的版本。 yml配置好以后我们还要对druid进行相关的配置 先在demo包下建一个config包，然后在config创建DruidConfig类,在此之前因为我们会需要写getset方法我们引入一下Lombok 1234567&lt;!-- lombok --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.4&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 下面的是配置类的Java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package com.ccsert.demo.config;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.support.http.StatViewServlet;import lombok.Getter;import lombok.Setter;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.web.servlet.ServletRegistrationBean;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Primary;import org.springframework.stereotype.Component;import java.sql.SQLException;@Component@ConfigurationProperties(prefix = "spring.datasource")@Getter@Setterpublic class DruidConfig &#123; private final Logger logger = LoggerFactory.getLogger(DruidConfig.class); private String driverClassName; private String url; private String username; private String password; private int initialSize; private int minIdle; private int maxActive; private long maxWait; private long timeBetweenEvictionRunsMillis; private long minEvictableIdleTimeMillis; private String validationQuery; private boolean testWhileIdle; private boolean testOnBorrow; private boolean testOnReturn; private boolean poolPreparedStatements; private int maxPoolPreparedStatementPerConnectionSize; private long removeAbandonedTimeoutMillis; private boolean removeAbandoned; private boolean logAbandoned; private boolean logDifferentThread; private String filters; private String connectionProperties; private boolean useGlobalDataSourceStat; //Druid 监控 Servlet 配置参数 private String druidRegistrationUrl; private boolean resetEnable; private String loginUsername; private String loginPassword; // Filters 配置参数 private String filtersUrlPatterns; private String exclusions; private int sessionStatMaxCount; private boolean sessionStatEnable; private String principalSessionName; private boolean profileEnable; @Bean(initMethod = "init", destroyMethod = "close") @Primary public DruidDataSource dataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driverClassName); dataSource.setUrl(url); dataSource.setUsername(username); dataSource.setPassword(password); dataSource.setInitialSize(initialSize); dataSource.setMinIdle(minIdle); dataSource.setMaxActive(maxActive); dataSource.setMaxWait(maxWait); dataSource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis); dataSource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis); dataSource.setValidationQuery(validationQuery); dataSource.setTestWhileIdle(testWhileIdle); dataSource.setTestOnBorrow(testOnBorrow); dataSource.setTestOnReturn(testOnReturn); dataSource.setPoolPreparedStatements(poolPreparedStatements); dataSource.setMaxPoolPreparedStatementPerConnectionSize(maxPoolPreparedStatementPerConnectionSize); dataSource.setRemoveAbandonedTimeoutMillis(removeAbandonedTimeoutMillis); dataSource.setRemoveAbandoned(removeAbandoned); dataSource.setLogDifferentThread(logDifferentThread); try &#123; dataSource.setFilters(filters); &#125; catch(SQLException e) &#123; e.printStackTrace(); logger.error("Druid URL过滤设置失败", e); &#125; dataSource.setConnectionProperties(connectionProperties); dataSource.setUseGlobalDataSourceStat(useGlobalDataSourceStat); return dataSource; &#125; @Bean public ServletRegistrationBean druidServlet() &#123; ServletRegistrationBean servletBean = new ServletRegistrationBean(new StatViewServlet(), druidRegistrationUrl); servletBean.addInitParameter("resetEnable", String.valueOf(resetEnable)); servletBean.addInitParameter("loginUsername", loginUsername); servletBean.addInitParameter("loginPassword", loginPassword); return servletBean; &#125;&#125; 紧接着我们让druid支持事务，在config包下创建一个TransactionConfig类 在此之前因为需要用到mybatis的注解，我们先将mybatis的依赖引入 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 然后下面是Java代码 12345678910111213141516171819202122232425262728293031package com.ccsert.demo.config;import com.alibaba.druid.pool.DruidDataSource;import org.mybatis.spring.annotation.MapperScan;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.AutoConfigureAfter;import org.springframework.context.annotation.Configuration;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.transaction.PlatformTransactionManager;import org.springframework.transaction.annotation.EnableTransactionManagement;import org.springframework.transaction.annotation.TransactionManagementConfigurer;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */@Configuration@EnableTransactionManagement@AutoConfigureAfter(&#123;DruidConfig.class&#125;)@MapperScan(basePackages = &#123;"Mybatis 的 DAO 接口所在的包路径"&#125;)public class TransactionConfig implements TransactionManagementConfigurer &#123; @Autowired private DruidDataSource mDataSource; @Override public PlatformTransactionManager annotationDrivenTransactionManager() &#123; return new DataSourceTransactionManager(mDataSource); &#125;&#125; 最后我们配置一下druid的监控界面 在上面的DruidConfig类中加入一个方法 123456789@Beanpublic ServletRegistrationBean druidServlet() &#123; ServletRegistrationBean servletBean = new ServletRegistrationBean(new StatViewServlet(), druidRegistrationUrl); servletBean.addInitParameter("resetEnable", String.valueOf(resetEnable)); servletBean.addInitParameter("loginUsername", loginUsername); servletBean.addInitParameter("loginPassword", loginPassword); return servletBean;&#125; 这样就配置完毕了 然后我们开始集成mybatis，这个时候先不要着急访问druid的监控界面，也不要着急启动项目，因为我们还没有mapper 接口。 SpringBoot集成mybatis我们这里使用xml写sql所以在刚才的yml配置里加上一条配置用于扫描mapper.xml的映射文件。 123mybatis: mapper-locations: classpath:mappers/**/*Mapper.xml type-aliases-package: com.ccsert.demo.*.model 然后在resources下建一个文件夹名字为mappers 其实这样已经差不多可以使用了，这里我们先不着急使用 先集成一下通用mapper SpringBoot集成通用mapper先引入通用mapper 123456&lt;!-- 通用mapper --&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 然后我们在config包下建立一个MyBatisConfig 类用于配置通用mapper 1234567891011121314151617181920212223242526272829303132333435package com.ccsert.demo.config;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import tk.mybatis.mapper.common.Mapper;import tk.mybatis.spring.mapper.MapperScannerConfigurer;import java.util.Properties;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */@Slf4j@Configurationpublic class MyBatisConfig &#123; @Bean public MapperScannerConfigurer mapperScannerConfigurer()&#123; log.info("加载MyBatisConfig....."); MapperScannerConfigurer mapperScannerConfigurer = new MapperScannerConfigurer(); mapperScannerConfigurer.setSqlSessionFactoryBeanName("sqlSessionFactory"); mapperScannerConfigurer.setBasePackage("com.ccsert.demo.login.dao"); Properties properties = new Properties(); properties.setProperty("mappers", Mapper.class.getName()); properties.setProperty("notEmpty", "false"); properties.setProperty("IDENTITY", "MYSQL"); properties.setProperty("ORDER","BEFORE"); mapperScannerConfigurer.setProperties(properties); return mapperScannerConfigurer; &#125;&#125; 好了结束了，就这么点点东西 我们直接开始使用测试一下 SpringBoot Smm使用在demo新建一个login包吧 然后在login包中建立dao，controller，service，model四个包，弄完以后大概就是这样 然后我们先建立一个简单的用户表，并新增些数据 1234567891011121314151617181920212223242526272829303132333435/*Navicat MySQL Data TransferSource Server : 本地Source Server Version : 50624Source Host : 127.0.0.1:3306Source Database : demoTarget Server Type : MYSQLTarget Server Version : 50624File Encoding : 65001Date: 2019-02-11 14:43:32*/SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for user_info-- ----------------------------DROP TABLE IF EXISTS `user_info`;CREATE TABLE `user_info` ( `id` int(11) NOT NULL AUTO_INCREMENT, `user_name` varchar(255) DEFAULT NULL, `password` varchar(255) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user_info-- ----------------------------INSERT INTO `user_info` VALUES ('1', 'ccsert', '123456');INSERT INTO `user_info` VALUES ('2', 'root', '654321');INSERT INTO `user_info` VALUES ('3', 'admin', '8848');INSERT INTO `user_info` VALUES ('4', '来个中文名', '111aaa'); 然后我们从实体类开始写 然后在model下建立一个实体类UserInfo，这里注意一下，我踩过几次坑了，这里必须使用驼峰命名法，因为我们的表名是带 _ 的所以因该从这里我们命名应当是UserInfo ，我们的通用mapper是根据实体类名去找表的。 1234567891011121314151617package com.ccsert.demo.login.model;import lombok.Getter;import lombok.Setter;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */@Getter@Setterpublic class UserInfo &#123; private Integer Id; private String UserName; private String Password;&#125; 接着是dao下建立一个UserInfoMapper接口，并继承通用mapper类 12345678910111213package com.ccsert.demo.login.dao;import com.ccsert.demo.login.model.UserInfo;import tk.mybatis.mapper.common.BaseMapper;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */public interface UserInfoMapper extends BaseMapper&lt;UserInfo&gt; &#123;&#125; 然后在service包下建立UserInfoService接口 在接口里写一个查询所有的方法 12345678package com.ccsert.demo.login.service;import com.ccsert.demo.login.model.UserInfo;import java.util.List;public interface UserInfoService &#123; List&lt;UserInfo&gt; selectAll();&#125; 接着在service包下建立一个impl的包 然后在包内建一个UserInfoService的实现类UserInfoServiceImpl 1234567891011121314151617181920212223242526package com.ccsert.demo.login.service.impl;import com.ccsert.demo.login.dao.UserInfoMapper;import com.ccsert.demo.login.model.UserInfo;import com.ccsert.demo.login.service.UserInfoService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */@Servicepublic class UserInfoServiceImpl implements UserInfoService &#123; @Autowired private UserInfoMapper userInfoMapper; @Override public List&lt;UserInfo&gt; selectAll() &#123; List&lt;UserInfo&gt; userInfos = userInfoMapper.selectAll(); return userInfos; &#125;&#125; 最后是controller包下建立一个UserInfoController 123456789101112131415161718192021222324252627package com.ccsert.demo.login.controller;import com.ccsert.demo.login.model.UserInfo;import com.ccsert.demo.login.service.UserInfoService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/** * @author 段瑜 * @version V1.0 * @Description: TODO * @date */@RestController@RequestMapping("/user")public class UserInfoController &#123; @Autowired private UserInfoService userInfoService; @RequestMapping("getall") public List&lt;UserInfo&gt; selectAll()&#123; List&lt;UserInfo&gt; userInfos = userInfoService.selectAll(); return userInfos; &#125;&#125; 最后我们还要在启动类上加一个mapper扫描的注解 1@MapperScan("com.ccsert.demo.login.dao") 导包时请注意，导入import tk.mybatis.spring.annotation.MapperScan;这个包 记得在事务配置上改为自己dao接口的路径 1@MapperScan(basePackages = &#123;"com.ccsert.demo.login.dao"&#125;) 我们运行一下，按照我写代码的方式，多半是要报错的。 1org.springframework.context.ApplicationContextException: Unable to start web server; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryConfiguration$EmbeddedTomcat': Initialization of bean failed; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration': Unsatisfied dependency expressed through method 'setConfigurers' parameter 0; nested exception is org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'transactionConfig': Unsatisfied dependency expressed through field 'mDataSource'; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'dataSource' defined in class path resource [com/ccsert/demo/config/DruidConfig.class]: Bean instantiation via factory method failed; nested exception is org.springframework.beans.BeanInstantiationException: Failed to instantiate [com.alibaba.druid.pool.DruidDataSource]: Factory method 'dataSource' threw exception; nested exception is java.lang.NoClassDefFoundError: org/apache/log4j/Logger 果然是报错了(ノへ￣、) 不过这个错看起来很好解决，末尾说找不到log4j,讲道理导入log4j的依赖就完事了 12345&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt;&lt;/dependency&gt; 导入后重新启动项目是会又警告的，虽然开发运行没有影响但是在生产打包为jar可能会报错，这是因为springboot默认的日志是logback，而logback和log4j发生冲突了。 我们把logback排除掉即可。 然而真相并不是这样，其实是druid的锅，既然都已经给了更好的logback，我们就直接用就好哪里还要换一个又屏蔽一个的？(￣_,￣ ) 我们只要在yml的配置文件中去掉 filters: stat,wall,log4j 的log4j就完事了 上面的那个log4j我就放出来看看而已不用加进去。嘿嘿嘿~~ 我们最后在yml配置里加一个日志的配置 12345logging: file: logs/mass.log level: org.springframework: info com.ccsert: DEBUG 然后就能打印sql了。 然后再次运行，果断运行成功，其实前面的报错都是我装的，我早就考虑到这些问题了。（其实我压根不知道，还找了半天的错） 输入http://localhost:8080/user/getall访问 我们访问一下druid的监控 http://localhost:8080/druid/index.html 然后我们点击sql监控 我们可以看到我们之前所执行的sql都会被druid监控 总算搞完了，后面有时间会继续集成使用的组件。 这里感谢简书一位大佬的支持，其中有些代码摘抄于这位朋友的文章 附上原文链接https://www.jianshu.com/p/9dc6f4418a06]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机下Linux基本安装]]></title>
    <url>%2F2019%2F01%2F29%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%8BLinux%E5%9F%BA%E6%9C%AC%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[第一步：工具准备所需要的工具有，vm虚拟机安装包，centos7发行版本，ok就这些，这里选择centos发行版本的原因是一般企业级的服务器都是他，7版本是最新版本，很多企业级也开始更换为最新版本。 这里我提供centos和vm虚拟机破解版的百度网盘链接 链接: https://pan.baidu.com/s/1oU26U89LP71OMX1PGfkHTg 提取码: 98vs 这里不提供vm虚拟机的安装教程，关于vm虚拟机安装请自行百度。后面可能有涉及到一些常用命令，可能会解释可能不会解释，未解释到位的请提出，或自行百度了解。 第二步：虚拟机创建首先创建虚拟机，看图就好 第三步：安装centos7系统]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vm虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带图片的博客]]></title>
    <url>%2F2019%2F01%2F29%2F%E5%B8%A6%E5%9B%BE%E7%89%87%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这里是带图片的博客 这里我会显示一张图片]]></content>
  </entry>
</search>
